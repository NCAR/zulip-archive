[
    {
        "content": "<p>Hi, <br>\nI'm trying to use KMT to plot the bottom velocity field of some POP output. In the past I've been just extracting a specific level with  xarray (mfds.UVEL.isel(z_t=0), for example) but that won't work because KMT is a 2D field and z_t is 1D.   I presume this is simple, but can anyone provide an example or guidance on this? <br>\nThanks in advance.</p>",
        "id": 96957,
        "sender_full_name": "Mira Berdahl",
        "timestamp": 1711046707
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"28\">@Kristen Krumhardt</span> or <span class=\"user-mention\" data-user-id=\"311\">@Lev Romashkov</span> might have a better way of doing this, but for temperature I think you want something like</p>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"n\">TEMP_BOTTOM</span> <span class=\"o\">=</span> <span class=\"n\">xr</span><span class=\"o\">.</span><span class=\"n\">full_like</span><span class=\"p\">(</span><span class=\"n\">ds</span><span class=\"p\">[</span><span class=\"s1\">'TEMP'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">isel</span><span class=\"p\">(</span><span class=\"n\">z_t</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">nan</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">60</span><span class=\"p\">):</span>\n    <span class=\"n\">TEMP_BOTTOM</span><span class=\"o\">.</span><span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">where</span><span class=\"p\">(</span><span class=\"n\">ds</span><span class=\"p\">[</span><span class=\"s1\">'KMT'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">data</span> <span class=\"o\">==</span> <span class=\"n\">k</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ds</span><span class=\"p\">[</span><span class=\"s1\">'TEMP'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">isel</span><span class=\"p\">(</span><span class=\"n\">z_t</span><span class=\"o\">=</span><span class=\"n\">k</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">TEMP_BOTTOM</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>and for <code>UVEL</code> you would use</p>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code><span class=\"n\">UVEL_BOTTOM</span> <span class=\"o\">=</span> <span class=\"n\">xr</span><span class=\"o\">.</span><span class=\"n\">full_like</span><span class=\"p\">(</span><span class=\"n\">ds</span><span class=\"p\">[</span><span class=\"s1\">'UVEL'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">isel</span><span class=\"p\">(</span><span class=\"n\">z_t</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">nan</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">60</span><span class=\"p\">):</span>\n    <span class=\"n\">UVEL_BOTTOM</span><span class=\"o\">.</span><span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">where</span><span class=\"p\">(</span><span class=\"n\">ds</span><span class=\"p\">[</span><span class=\"s1\">'KMU'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">data</span> <span class=\"o\">==</span> <span class=\"n\">k</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ds</span><span class=\"p\">[</span><span class=\"s1\">'UVEL'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">isel</span><span class=\"p\">(</span><span class=\"n\">z_t</span><span class=\"o\">=</span><span class=\"n\">k</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">UVEL_BOTTOM</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>Note the subtle difference between using <code>KMT</code> in the logical expression <code>ds['KMT'].data == k+1</code> for temperature and <code>KMU</code> in <code>ds['KMU'].data == k+1</code> for <code>UVEL</code> -- the tracers are computed at cell centers, while velocities are computed at cell vertices, and the bathymetry is slightly different between the two.</p>",
        "id": 96977,
        "sender_full_name": "Michael Levy",
        "timestamp": 1711117503
    },
    {
        "content": "<p>Here's another way, but sometimes it takes forever or gets dask errors, depending on how big your dataset is (this example is for variables <code>TEMP</code> and <code>POC_FLUX_IN</code>):</p>\n<div class=\"codehilite\"><pre><span></span><code>def field_at_bottom(da):\n    &quot;&quot;&quot;return a field indexed at the model&#39;s bottom layer&quot;&quot;&quot;\n\n    tmp_bot = xr.DataArray(np.ones(da[:, 0, :, :].shape) * np.nan,\n                           dims=tuple(da.dims[i] for i in [0, 2, 3]),\n                           coords={c: da.coords[c] for c in [&#39;time&#39;]},\n                          )\n\n    assert KMT.shape == da.shape[-2:]\n\n    for j in range(len(da.nlat)):\n        for i in range(len(da.nlon)):\n            if KMT[j, i] &gt; 0:\n                k = int(KMT[j, i] - 1)\n                tmp_bot.values[:, j, i] = da[:, k, j, i]\n    return tmp_bot\n\nfor v in [&#39;TEMP&#39;, &#39;POC_FLUX_IN&#39;,]:\n    template = dsets[v][v][:, 0, :, :].drop(&#39;z_t&#39;)\n    dso[f&#39;{v}_bottom&#39;] = xr.map_blocks(\n        field_at_bottom, dsets[v][v],\n        template=template\n    ).compute()\n</code></pre></div>",
        "id": 96978,
        "sender_full_name": "Kristen Krumhardt",
        "timestamp": 1711117861
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"10\">@Michael Levy</span> and <span class=\"user-mention\" data-user-id=\"28\">@Kristen Krumhardt</span>  Thanks for the help here! These work.</p>",
        "id": 97023,
        "sender_full_name": "Mira Berdahl",
        "timestamp": 1711146806
    },
    {
        "content": "<p>Mira, <br>\nHere is a third option. <br>\nYou can simply use isel like you did to get the surface velocity (z_t=0) except that you are going to use KMU to select the bottom cells. <br>\nSee example below. </p>\n<div class=\"codehilite\"><pre><span></span><code>uvel = ds.UVEL\nkmu = ds.KMU.astype(&#39;int&#39;) - 1\nUbot = UVEL.isel(z_t=kmu)\n</code></pre></div>",
        "id": 97392,
        "sender_full_name": "Fred Castruccio",
        "timestamp": 1712007198
    }
]